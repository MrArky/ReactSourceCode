## 学习笔记（本笔记根据 React18.2.0 编写）

### 引言
在看过一些文章后，首先知道了在React架构中的几个核心的概念（当然没了解过也无所谓）：
1. **Scheduler**（调度器）—— React在渲染的过程中能够识别任务的优先级，优先级高的任务将先进入Reconciler：
   - 在项目源码中可以看到以下五个优先级别,下面是搬运过来的源码（[源码](https://github.com/MrArky/ReactSourceCode/blob/main/packages/react-18.2.0/packages/scheduler/src/SchedulerPriorities.js#L12-L18)）:
``` JavaScript
/** 没有优先级 */
export const NoPriority = 0;
/** 立即的、优先的，这里可以认为是最高优先级 */
export const ImmediatePriority = 1;
/** 用户阻塞优先级 */
export const UserBlockingPriority = 2;
/** 普通优先级 */
export const NormalPriority = 3;
/** 低优先级 */
export const LowPriority = 4;
/** 惰性优先级 */
export const IdlePriority = 5;
```
   - 基于优先级思想，在任务执行过程中可能会出现“插队”，这就需要在任务处理过程中实现打断、恢复和中止。
2. **Reconciler**（协调器）—— 负责找出变化的组件。
3. **Render**（渲染器）—— 负责将变化的组件（重新）渲染到页面上。
   - 在React中，对渲染器进行了解耦，作为独立的包运行。常见的渲染器有： `dom-render（react-dom）` 、 `native-render（react-native-render）` 和用于绘图的 `art-render(react-art)` 等。
   - 根据渲染平台，可以设计自己的 render ,如 `win-render` 用于 `window` 平台桌面软件页面渲染。
### Scheduler（调度器）
**调度器是在 **React16** 中才引入的一个新的模块，那为什么要引入这个模块？**

浏览器是多线程的架构，在浏览器中UI渲染、JS执行、事件、定时器、请求等都是独立的线程。由于JS可以直接操作DOM，JS代码执行和UI渲染实际上是互斥的，在JS执行期间会阻塞UI的渲染。目前主流的屏幕刷新频率是`60Hz`，如果在每1帧中（16.667ms），需要完成JS执行和UI渲染，一旦遇到JS执行时间超过了16.667ms，就没有时间进行UI绘制工作，在页面交互中反馈就是页面卡顿。

这里可以做进一步探讨，比如用户现在点击按钮调用了一个方法，这个方法需要执行2秒，如图：

在 **React16** 之前，执行 `Render` 后，会根据 `JSX` 生成虚拟DOM树，
